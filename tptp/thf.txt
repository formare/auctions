% Using thf mainly because I don't know how to use first-order axiom schemes in TPTP's fof (in particular, I don't know how to use the assounderung axioms).

thf(Pow,definition,
  ( Pow = 
    ( ^ [ A : $i > $o, a : $i > $o ] : (subset @ A @ a) )
  )
).
  
thf(Runiq,definition,
  (Runiq = (^ [ R :$i > $i > $o ] : 
    (! [ x: $i , y: $i, z: $i] : ( R @ x @ y & R @ x @ z ) => y = z ))
  )).
  
thf(allInjections, definition,
  (allInjections = ^ [ X: $i > $o, Y: $i > $o, R: ($i > $i > $o) ] : 
    (rel_domain @ R = X & subset @ (rel_codomain @ R) @ Y & Runiq @ R & Runiq @ (rel_inverse @ R )) 
  )
).

thf(nonOverlapping, definition, (
    nonOverlapping = (^ [ F : ($i > $o) > $o ] : 
    			(! [ X : $i > $o, Y : $i > $o ] :  
    				(F@X & F@Y) => ( intersection @ X @ Y = emptyset <=>  (X=Y)) ))
)).

thf(bigUnion, definition, (
	bigUnion = (^ [F : (($i > $o) > $o), x : $i] : (? [ X : $i > $o ] : F @ X & X @ x))
)).

thf(allPartitions, definition,
  allPartitions = ^ [ X: $i > $o, P: ($i > $o) > $o ] : (nonOverlapping P & bigUnion P = X)
).

thf(allAllocations, definition, 
  allAllocations = ^ [ N : $i > $o, G : $i > $o, A : $i > ($i > $o) > $o ] : ( bigUnion
  
  (^ [ X : ($i > $i > $o) > $o ] : ? [ M : $i > $o, Y : ($i > $o) > $o ] : X=allInjections M Y & subset M N & allPartitions @ G @ Y)
  
  ) 
).

thf(outside, definition, 
	outside = ^ [ X : $i > $o, R : $i > $i > $o ] : restrict_rel_domain @ R @ (complement @ X)
).

thf(soldAllocations, definition,
  soldAllocations = ^ [ seller : $i, N : $i > $o, G : $i > $o ] : 
  		      (fun_image @ outside @ (singleton @ seller)) @ (allAllocations @ N @ G ))
).

thf(setDiff, definition, 
setDiff = ^ [ X : $i > $o, Y : $i > o, x : $i ] : intersection @ X @ (complement @ Y) @ i).

thf(allAllocationsInPowerset, conjecture, 
subset @ (allAllocations @ N @ G) @ (
Pow @ (cartesian_product @ N @ (setDiff @ (Pow @ G) @ (singleton @ emptyset)))
) 
).

thf(soldAllocationRestriction, conjecture, 
! [ A : $i > ($i > $o) > $o, n : $i, N : $i > $o, G : $i > $o ] : soldAllocations @ N @ G @ A => in @ (outside @ (singleton @ n) @ A) @ 
(soldAllocations @ (setDiff @ N @ (singleton @ n)) @ G)
).

