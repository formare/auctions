#+TITLE:     Demo of Pillage Games Lemma 1 and 2 (eco1.nb)
#+AUTHOR:    Christoph Lange, Manfred Kerber, Colin Rowat
#+EMAIL:     c.lange@cs.bham.ac.uk, m.kerber@cs.bham.ac.uk, c.rowat@bham.ac.uk
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+STARTUP:   hidestars
#+OPTIONS:   H:1 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:showall toc:t ltoc:t mouse:underline buttons:t path:../lib/scripts/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:   
#+LINK_HOME: 
#+XSLT:
#+STYLE: <style type="text/css"> .timestamp { color: purple; font-weight: bold; } </style>

* Prerequisites
** TODO Before going into detail about this, it would be good to have seen the following already:
*** the power function axioms
*** Lemma 1 ("almost trivial", easy proof)
*** the dominance relation
*** Lemma 2 (trivial as well)
* The basic axioms of pillage games
** Focus: What does the formalization look like?  How does Theorema work at all?
** Start with the preliminary definitions
*** Definition["agents"]
*** Definition["appropriateLength"]
    You have to make all of this explicit; on paper, it's often implicit.
*** Show a very simple proof (of Lemma["1inI"]) to get a feeling
**** Not just a pointless lemma, but actually we'll need it later on.
**** This proof involves set theory, and computation on numbers (We'll get to that shortly)
**** Run proof, briefly show failed cases, then clean up and show
**** Theorema feature: paper-style presentation of a proof
**** To explain computation, show the computation of a concrete set of numbers
*** Show the slightly more complex proof of Lemma["1and2inI"], first with the default search depth of 30, then with 33
*** Show Definition["allocation"]; talk about types
**** Theorema is untyped
***** That's convenient when you quickly want to write down something
***** But it may lead to errors that are hard to find, when you compare apples to pears and the system doesn't warn you.
***** So if you want to avoid such mistakes, you'd better provide explicit type information, as you see here.
***** Strongly typed systems would fail with an error when you pass something with a wrong type – OTOH quite frustrating, because if you need types everywhere, you can easily get them wrong
** Definition["WC"]
** Definition["WR"]
*** Definition["WR contrapositive"]
**** Redundant, but needed to get the proof done, because it turned out that during the proof Theorema couldn't make use of the original formulation, but was in a situation where it rather expected the contrapositive.
** Definition["SR"]
** Definition["powerfunction"]
   combines the three axioms
* Lemma 1 (representation of the power function)
** Now this is quite easy to state
** We need the auxiliary Axiom["trichotomy"] because Theorema doesn't have any special knowledge about real numbers.
** just scroll through the cleaned-up proof
** This works with the PredicateProver: simple first-order logic.  Theorema doesn't have one hard-wired logic, but comes with several logics.
* Anonymity and dominance
** Axiom["AN"]
** Definition["WinLose"]
** Definition["dominates"]
* Lemma 2
** Lemma["ANdominates"]
** Automated proof of the direct statement doesn't work
*** run it, wait some time.  Reasons:
**** We don't know how long it will take; it may try forever (undecidability of first-order logic!)
**** We didn't provide enough background knowledge
*** abort proof; Theorema will show incomplete proof object (feature!)
*** at some positions: What do you expect, why doesn't Theorema proceed this way?
*** You realize that you need additional axioms: What would be additional information that would be required at a certain point?  (Also need a good understanding of the /paper/ form of the proof)
*** Suitable axioms can be found by theory exploration
** Need additional explicit background knowledge:
*** Lemma["perm swap"]
**** Show its proof, first without, then with built-in “=”: interesting due to the case "2=1"
***** Theorema has no knowledge about numbers.  Formalizing the natural numbers (an infinite set!) would require second-order logic (Peano axioms: induction).
***** So for now, “1” and “2” are just unknown symbols, not instances of the Peano axioms
***** We can ask Theorema to use some built-in knowledge about the equality of natural numbers (second proof attempt).
*** Lemma["AN swap"]
**** This is a concrete instance of the anonymity axiom for the non-trivial case of permuting 2 agents (machines don't have a good intuition of non-triviality)
**** Not straightforward to prove: We provide it as an assertion
***** Simply providing unproven assertions doesn't work in other systems
***** In Mizar you have to prove everything from the built-in axioms of set theory.
***** In other systems you need to explicitly call anything unproven an axiom.
***** Therefore, Theorema is closer to mathematical practice.  (Something that has been established in literature doesn't have to be proven again, e.g. the intermediate value theorem.)
*** Lemma["ANdominates 1"] and its proof, and what it uses
*** Lemma["ANdominates 2"] analogously
