#+TITLE:     Lessons Learned from Formalisation with Theorema
#+AUTHOR:    Christoph Lange, Manfred Kerber, Colin Rowat
#+EMAIL:     c.lange@cs.bham.ac.uk, m.kerber@cs.bham.ac.uk, c.rowat@bham.ac.uk
#+DESCRIPTION:
#+KEYWORDS:
#+LANGUAGE:  en
#+STARTUP:   hidestars
#+OPTIONS:   H:1 num:t toc:t \n:nil @:t ::t |:t ^:t -:t f:t *:t <:t
#+OPTIONS:   TeX:t LaTeX:t skip:nil d:nil todo:t pri:nil tags:not-in-toc
#+INFOJS_OPT: view:showall toc:t ltoc:t mouse:underline buttons:t path:../../lib/scripts/org-info.js
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+LINK_UP:   
#+LINK_HOME: 
#+XSLT:
#+STYLE: <style type="text/css"> .timestamp { color: purple; font-weight: bold; } </style>

* Defining the basic concepts
** Definitions                                                      :concept:
*** Definition["name", definition]                                   :syntax:
*** can use spaces; names are arbitrary strings                      :syntax:
*** when there are multiple definitions/axioms about something, don't use enumerated names ("def1", "def2") but always try to be descriptive :methodologyTP:
*** give any semantic unit a name (instead of writing large expressions), so that you can refer to it from somewhere else :methodologyTP:
**** in subsequent steps it will prove necessary to refactor existing semantic units into smaller ones, as there will be a need to reuse the smaller ones
***** We first had range, antisymmetry and transitivity defined for a whole preference profile (and thus \forall v \in {1, …, N}), but then needed to say that these also hold for a constitution function.  So we refactored the "preference profile *" axioms into "preference function *" axioms (removing the \forall v) and one new axiom that states that a preference profile is a set of N preference functions.
***** often this will even look more concise
**** refactoring for reuse may lead to the insight that we actually don't /need/ multiple occurrences of the same thing
     We had this example in Maskin/Milgrom's version of Vickrey's theorem on second-price auctions (Colin's definition 7, x_j = p_j = 0):
     1. On paper, this expression occurred twice.
     2. So we thought, let's give this concept a name: “loser of an auction := one who doesn't get the good, and who doesn't pay anything”
     3. Then we realized: Why do we have to say that all j \in N\M are losers, /and/ that all but one j \in M are /also/ losers?  I.e. why not just say that all but one j \in N are losers?
*** try to think of everything you may need to define        :methodologyTP:
**** if you don't, then things won't work, and you will be forced to give more definitions
*** introduce locally-scoped variables in definitions with “any[variable-name]” :syntax:
*** syntax is case-sensitive                                         :syntax:
** create new cells for new expressions                              :syntax:
*** Mathematica can fold cells                                      :interaction:
**** can select part of a cell but then can't extend selection into sibling cell :bug:
**** Ctrl+Shift+} closes all folds
*** can highlight cell with left mouse button, set its type from context menu
**** e.g. initialization cell
**** can evaluate them via “Evaluation → Evaluate Initialization Cells”
*** Can select multiple cells and group them into a higher-level cell
*** just one undo step :-(                                  :bug:interaction:
** selecting expressions: useful for copy/paste into other e.g. definitions :interaction:
*** can sequentially click on something to enlarge the selection expression-wise
** test often, with small units (cells) of evaluation (unforgiving) :methodologySW:
*** use Compute                                               :methodologySW:
*** mistakes we made:                                         :methodologyTP:
**** in transitivity, used k as an alternative index and for the overall number of alternatives (now M)
**** in transitivity, quantified over i and j but forgot to quantify over k
** save often (sometimes loses data or crashes)               :methodologySW:
** copy/paste cells or subexpressions and then adapt them     :methodologySW:
   * maintain a “template” document with tricky expressions, or copy/paste from any existing document
** instead of {1, …, n} one can have indexed sets such as {v_1, …, v_n} for disambiguation and “type-safety” :methodologyTP:syntax:
*** trade-offs involved here:
**** trade-off between precision (v_1) and conciseness (simply 1)
**** trade-off between using sets (e.g. f(x) \in {a, b, c} – more concise but computationally more complex) vs. expanding it into logic (f(x) = a \vee f(x) = b \vee f(x) = c) :complexity:
**** general notes:
***** Without internal knowledge of Theorema, you don't know the computational consequences of choosing some approach :complexity:
      \forall_{i\in A[m]} is computationally inefficient!
***** if you once introduced an indexed set, use it consistently!
      E.g. in the formalisation of Geanakoplos' proofs of Arrow's theorem we had defined {v_1, …, v_n} as above but then indexed a preference profile \pi{}t with integers (e.g. \pi{}t_1 instead of \pi{}t_{v_1})
** notation:
*** can't arbitrarily mess with built-in operators, e.g. use subscripts like <_k :paper:
*** input syntax:                                                    :syntax:
**** auto-completion with Ctrl+K
**** syntax for index: Ctrl+_
**** leave subscript part: Ctrl+Space
**** Esc "pi" Esc → \pi
**** TeX names work most of the time
**** input “\forall x” as a box with \forall on top and variables below it
***** if in doubt, use separate quantifiers for all variables
**** if in doubt, use additional brackets
***** in particular, \forall binds stronger than = (which is the value assignment operator in Mathematica, overloaded with logical equivalence in Theorema) :bug:
****** one can find out using structural selection
****** even from the proof it wasn't clear that this was wrong
****** Theorema 2 will introduce a separate operator for logical equivalence
** Can't always use quantifiers with conditions (or can one, in Theorema?), therefore need to rewrite :methodologyTP:
*** \forall x \in M . p(x) ↝ \forall x . x \in M \Rightarrow p(x)
*** \exists x \in M . p(x) ↝ \exists x . x \in M \wedge p(x)
** make all dependencies of a definition explicit             :methodologyTP:
*** a lot tend to be implicit on paper                                :paper:
*** on the other hand, not all information is /relevant/ for a proof
    * e.g. properties of something:
      * that a number is real (x \in ℝ), with all of the properties of the real numbers
      * instead it may be a sufficient prerequisite for the proof to know that x \ge 0.
    * or additional observations that can be made about something, or conditions that hold for something, but merely serve explanatory purposes (e.g. in our Maskin/Milgrom/Vickrey second-price auction formalisation, that a [bidding] strategy involves a random variable, whose distribution is described by a density function – apparently the proof does not rely on this)
** it's often useful to make definitions as predicates instead of functions :methodologyTP:
   That is:
   * instead of e.g. f(0) := 1
   * write my-predicate(f) := ⊤ if f(0) ≡ 1
   Rationale: Proofs often don't deal with numerical values (such as f(0) = 1), but with /conditions/ on such values, e.g. “if x \ge 0 then f(x) = …”.
** Complexity and computational efficiency         :methodologyTP:complexity:
*** Typical patterns that make paper notation concise are not necessarily computationally efficient :paper:
    * indicator functions/index functions, and sums involving them (can better be phrased as conditional expressions)
** Advantages of machine formalisation
*** Paper formalisations may be insufficient                          :paper:
    * e.g. Inequality (1) in Maskin/Milgrom/Vickrey is represented in terms of “u_i(b)” on paper, rather than making explicit that an auction maps b ↦ <x,p> (bids to outcome, i.e. allocation and prices).  Also note that u_i had previously been defined without arguments!
**** machine formalisation may uncover errors/omissions in paper formalisation
     <2012-11-06 Tue>
     * In preparing the Theorema 2 formalisation of Vickrey we figured out that the “second highest bid” is ill-defined for a one-bidder auction.  Our Isabelle formalisation accidentally defined the maximum of the empty set as 0, which sets the second highest bid to 0 if there is only one bidder.
*** Formalisation in different logics                         :methodologyTP:
    <2012-12-02 Sun>
    Formalising in a certain logic forces you to think about certain aspects of a domain, which formalisation in some _other_ logic does not necessarily cover.  Therefore, formalising in one logic may help to detect conceptual errors in a formalisation in some other logic.  Concrete example: In the Isabelle auction theory toolbox, we had explicitly passed the number of participants $n$ to all predicates (as we needed it because of the formalisation of vectors as functions from ℕ to something).  Theorema has built-in support for vectors (actually: tuples).  Still we need the number of participants $n$ in many places, so we used a global quantifier $\forall_{valuation[v]} \dots where_{n=|v|}$ (as the valuations are the only information that is known before running a specific auction) – but many definitions in the _scope_ of this quantifier only use $n$ but not $v$.  This became apparent when formalising the same in CASL, as CASL does support global $\forall$ quantifiers but not “where”, so we had to state “exists n: Participants . n = length(v)” in a context where v was not bound, as it didn't occur on the left hand side of an axiom.  And Hets's static analysis detected it.
** Theories                                                         :concept:
*** group a number of related definitions/axioms into a theory
*** second argument (list of statements) probably needs to be a column vector :syntax:
**** TODO ask Wolfgang: didn't work for us                             :task:
* What can you prove from the basics?
** Stating a simple lemma                                     :methodologyTP:
*** looking at \pi t_1(a_1, a_1) = 0, we came up with the idea to state \pi(i, i) = 0 as a lemma
* Proofs                                                            :concept:
** need to make explicit what a proof should use            :syntax:Theorema:
** if a proper /proof/ doesn't work, then use Compute :methodologySW:Theorema:
** if you can't use definitions from a theory (because you got the syntax of the theory wrong), enumerate them explicitly in the Compute's "using". :methodologySW:Theorema:
** Compute needs "using" (your relevant definitions) and "built-in" parameters (any relevant Theorema functionality) :syntax:Theorema:
** if a computation/evaluation of a complex expression doesn't work, try a smaller one :methodologyTP:
** After a proof works, try whether it also works with fewer assumptions. :methodologyTP:
*** e.g. in the Isabelle proof of “lemma maximum_except_is_greater_or_equal” (auction/Vickrey.thy) it turned out that induction over n wasn't necessary. :Isabelle:
** Proving something in a complicated way (original Vickrey with 8 cases, starting with what b bids) on paper doesn't cost so much more than proving it in an easier way (here: Vickrey with top-level distinction "i wins/loses before"; then "i wins/loses afterwards").  On the computer, a complicated proof is a lot more painful; therefore this is a strong incentive to think twice about the paper version of the proof. :methodologyTP:paper:
* Isabelle                                                         :Isabelle:
** advantage: good feedback about syntax errors (whereas no such feedback in Theorema)
** can't evaluate set comprehension (works in Theorema)
   value "{i . i=1}"
** in jEdit: need to reload file (F5) sometimes when prover gets stuck
** Isabelle has a lot of syntactic sugar, which is not used by every author ⇒ makes it hard to find solutions on the Web
** neither jEdit nor ProofGeneral have equivalents to Mathematica's “expand selection”
** what one can "show" depends on the goal (i.e. outer syntax not valid per se)
** To see whether a proof is done, always check the "goal" output! :methodologySW:
** In the end, when you think you're done, you still often need "show ?thesis <by some trivial inference rule>".
** When developing the structure of a proof, use "show ?thesis sorry" as placeholders for proof steps that remain to be done. :methodologyTP:
** TODO ask whether one can have dependent types such as 1\le{}i\le{}n for a given n.
* sTeX                                                                 :sTeX:
** workflow                                                   :methodologyST:
   1. start with non-semantic LaTeX
   2. introduce modules for logical units
   3. introduce semantic macros for symbols
   4. make modules import each other as needed
