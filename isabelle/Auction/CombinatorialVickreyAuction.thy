(*
Auction Theory Toolbox (http://formare.github.io/auctions/)

Authors:
* Manfred Kerber <mnfrd.krbr@gmail.com>
* Christoph Lange <math.semantic.web@gmail.com>
* Colin Rowat <c.rowat@bham.ac.uk>
* Marco B. Caminati <marco.caminati@gmail.com>

Dually licenced under
* Creative Commons Attribution (CC-BY) 3.0
* ISC License (1-clause BSD License)
See LICENSE file for details
(Rationale for this dual licence: http://arxiv.org/abs/1107.3212)
*)

header {* soundness verification of combinatorial Vickrey auction *}

theory CombinatorialVickreyAuction
imports CombinatorialAuction
  Maximum
begin

(* the maximum revenue over all possible allocations (assuming relational allocations) *)
definition max_revenue :: "goods \<Rightarrow> participant set \<Rightarrow> bids \<Rightarrow> price"
where "max_revenue G N b = Max ((revenue_rel b) ` (possible_allocations_rel G N))"
(* we don't need the variant that assumes functional allocations, as it's really just the same *)

fun max_revenue_comp :: "goods \<Rightarrow> participant set \<Rightarrow> bids \<Rightarrow> price"
where "max_revenue_comp G N b = maximum_comp_list (possible_allocations_comp G N) (revenue_rel b)"

value "max_revenue_comp paper_example_goods paper_example_participants paper_example_bids"
value "max_revenue_comp cats_example_goods cats_example_participants cats_example_bids"

(* This is the "arg max", where max_revenue is the "max" (assuming relational allocations). *)
definition winning_allocations_rel :: "goods \<Rightarrow> participant set \<Rightarrow> bids \<Rightarrow> allocation_rel set"
where "winning_allocations_rel G N b = 
{ potential_buyer . revenue_rel b potential_buyer = max_revenue G N b }"

(* CL: probably not needed, neither for close-to-paper nor for computable version
(* This is the "arg max", where max_revenue is the "max" (assuming functional allocations). *)
definition winning_allocations_fun :: "goods \<Rightarrow> participant set \<Rightarrow> bids \<Rightarrow> allocation_fun set"
where "winning_allocations_fun G N b = 
{ (Y,potential_buyer) . revenue_fun b (Y,potential_buyer) = max_revenue G N b }"
*)

(* the unique winning allocation that remains after tie-breaking (assuming relational allocations) *)
fun winning_allocation_rel :: "goods \<Rightarrow> participant set \<Rightarrow> tie_breaker_rel \<Rightarrow> bids \<Rightarrow> allocation_rel"
where "winning_allocation_rel G N t b = t (winning_allocations_rel G N b)"

(* CL: probably not needed, neither for close-to-paper nor for computable version
(* the unique winning allocation that remains after tie-breaking (assuming functional allocations) *)
definition winning_allocation_fun :: "goods \<Rightarrow> participant set \<Rightarrow> tie_breaker_fun \<Rightarrow> bids \<Rightarrow> allocation_fun"
where "winning_allocation_fun G N t b = t (winning_allocations_fun G N b)"
*)

fun winning_allocations_comp_CL
where "winning_allocations_comp_CL G N b = (arg_max_comp_list
    (possible_allocations_comp G N)
    (revenue_rel b))"

value "winning_allocations_comp_CL
  paper_example_goods
  paper_example_participants
  paper_example_bids"

value "winning_allocations_comp_CL
  cats_example_goods
  cats_example_participants
  cats_example_bids"

fun winning_allocations_comp_MC where 
"winning_allocations_comp_MC G N b = (let all = possible_allocations_comp G N in
  map (nth all) (max_positions (map (revenue_rel b) all)))"

(*
value "winning_allocations_comp_MC 
  paper_example_goods
  paper_example_participants
  paper_example_bids"
*)

text {* the maximum sum of bids of all bidders except bidder @{text n}'s bid, computed over all possible allocations of all goods,
  i.e. the value reportedly generated by value maximization problem when solved without n's bids *}
definition \<alpha> :: "goods \<Rightarrow> participant set \<Rightarrow> bids \<Rightarrow> participant \<Rightarrow> price"
where "\<alpha> G N b n = max_revenue G (N - {n}) b"

text {* algorithmic version of @{text \<alpha>} *}
fun \<alpha>_comp :: "goods \<Rightarrow> participant set \<Rightarrow> bids \<Rightarrow> participant \<Rightarrow> price"
where "\<alpha>_comp G N b n = max_revenue_comp G (N - {n}) b"

(* CL: probably not needed, neither for close-to-paper nor for computable version
(* those goods that are allocated to someone who gets some goods *)
definition winners'_goods_fun :: "goods \<Rightarrow> participant set \<Rightarrow> tie_breaker_fun \<Rightarrow> bids \<Rightarrow> participant option \<Rightarrow> goods" 
where "winners'_goods_fun G N t b = inv (snd (winning_allocation_fun G N t b))"
*)

(* CL: probably not needed, neither for close-to-paper nor for computable version
definition remaining_value_fun :: "goods \<Rightarrow> participant set \<Rightarrow> tie_breaker_fun \<Rightarrow> bids \<Rightarrow> participant \<Rightarrow> price"
where "remaining_value_fun G N t b n =
  (\<Sum> m \<in> N - {n} . b m (winners'_goods_fun G N t b (Some m)))"
*)

text {* the sum of bids of all bidders except bidder @{text n} on those goods that they actually get,
  according to the winning allocation *}
definition remaining_value_rel :: "goods \<Rightarrow> participant set \<Rightarrow> tie_breaker_rel \<Rightarrow> bids \<Rightarrow> participant \<Rightarrow> price"
where "remaining_value_rel G N t b n =
  (\<Sum> m \<in> N - {n} . b m (eval_rel_or ((t (winning_allocations_rel G N b))\<inverse>) m {}))"

text {* algorithmic version of @{text remaining_value_rel} *}
fun remaining_value_comp :: "goods \<Rightarrow> participant set \<Rightarrow> tie_breaker_comp \<Rightarrow> bids \<Rightarrow> participant \<Rightarrow> price"
where "remaining_value_comp G N t b n =
  (\<Sum> m \<in> N - {n} . b m (eval_rel_or
    (* When a participant doesn't gain any goods, there is no participant \<times> goods pair in this relation,
       but we interpret this case as if 'the empty set' had been allocated to the participant. *)
    ( 
      (* the winning allocation after tie-breaking: a goods \<times> participant relation, which we have to invert *)
      (t (winning_allocations_comp_CL G N b))\<inverse>)
    m (* evaluate the relation for participant m *)
    {} (* return the empty set if nothing is in relation with m *)
  ))"

(*
definition payments_fun :: "goods \<Rightarrow> participant set \<Rightarrow> tie_breaker_fun \<Rightarrow> bids \<Rightarrow> participant \<Rightarrow> price"
where "payments_fun G N t = \<alpha> G N - remaining_value_fun G N t"
*)

(* the payments (assuming relational allocations) *)
definition payments_rel :: "goods \<Rightarrow> participant set \<Rightarrow> tie_breaker_rel \<Rightarrow> bids \<Rightarrow> participant \<Rightarrow> price"
where "payments_rel G N t = \<alpha> G N - remaining_value_rel G N t"

text {* algorithmic version of @{text payments_rel} *}
fun payments_comp :: "goods \<Rightarrow> participant set \<Rightarrow> tie_breaker_comp \<Rightarrow> bids \<Rightarrow> participant \<Rightarrow> price"
where "payments_comp G N t = \<alpha>_comp G N - remaining_value_comp G N t"

(* the payments (computational version, expanded to work around https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2013-July/msg00011.html
   until Isabelle2014 fixes the bug; see https://lists.cam.ac.uk/pipermail/cl-isabelle-users/2013-July/msg00024.html) *)
fun payments_comp_workaround :: "goods \<Rightarrow> participant set \<Rightarrow> tie_breaker_comp \<Rightarrow> bids \<Rightarrow> participant \<Rightarrow> price"
where "payments_comp_workaround G N t b n = 
  (* \<alpha>_comp G N *) max_revenue_comp G (N - {n}) b
  -
  (* remaining_value_comp G N t *) (\<Sum> m \<in> N - {n} . b m (eval_rel_or
    (* When a participant doesn't gain any goods, there is no participant \<times> goods pair in this relation,
       but we interpret this case as if 'the empty set' had been allocated to the participant. *)
    (
      (* the winning allocation after tie-breaking: a goods \<times> participant relation, which we have to invert *)
      (t (winning_allocations_comp_CL G N b))\<inverse>)
    m (* evaluate the relation for participant m *)
    {} (* return the empty set if nothing is in relation with m *)
  ))"

value "{(n, payments_comp paper_example_goods paper_example_participants hd paper_example_bids n) | n . n \<in> paper_example_participants}"
value "{(n, \<alpha>_comp paper_example_goods paper_example_participants paper_example_bids n) | n . n \<in> paper_example_participants}"

value "{(n, payments_comp cats_example_goods cats_example_participants hd cats_example_bids n) | n . n \<in> cats_example_participants}"
value "{(n, \<alpha>_comp cats_example_goods cats_example_participants cats_example_bids n) | n . n \<in> cats_example_participants}"

(* example for the single-good Vickrey auction as a special case of the combinatorial Vickrey auction *)
definition sga_goods :: goods where "sga_goods = {1::nat}"
definition sga_bids :: "(participant \<Rightarrow> price) \<Rightarrow> bids"
where "sga_bids b = (\<lambda> bidder goods . (
      if goods = sga_goods then b bidder else 0))"

value "hd (winning_allocations_comp_CL
  sga_goods
  {0::nat, 1, 2}
  (sga_bids (nth [23::nat, 42, 31]))
)"
value "{(x, payments_comp sga_goods {0::nat, 1, 2} hd (sga_bids (nth [23::nat, 42, 31])) x) | x . x \<in> {0::nat, 1, 2}}"

(* TODO CL: revise the following as per https://github.com/formare/auctions/issues/35 *)

(* TODO CL: we may need nVCG-specific notions of "admissible input" *)

(* the relation of all (input, outcome) pairs where
   * input is an admissible input to an nVCG auction, and
   * outcome is obtained from input according to the definitions above.
   For this relation we need to show that, given an arbitrary but fixed tie-breaker,
   for each admissible input, there is a unique, well-defined outcome. *)
definition nVCG_auctions :: "tie_breaker_comp \<Rightarrow> combinatorial_auction"
where "nVCG_auctions t = { ((G, N, b), (x, p)) | G N b x p .
  admissible_input G N b
  \<and> x = t (winning_allocations_comp_CL G N b)
  \<and> p = payments_comp G N t b }"

end

