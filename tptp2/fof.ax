%------------------------------------------------------------------------------
% File     : <For TPTP use only>
% Domain   : Set Theory
% Axioms   : Additional definitions for partitions 
% Version  : [ATT] axioms
% English  : 

% Refs     : [CKLR:SASI-EC15], Email to G. Sutcliffe
% Source   : [ATT]
% Names    : 

% Status   : Satisfiable
% Syntax   : <Don't worry about this one - we'll do it automatically>
% SPC      : <Don't worry about this one - we'll do it automatically>

% Comments : 
%------------------------------------------------------------------------------

%----- A family of sets X is non overlapping if its element are pairwise disjoint
%----- Alternatively, if it is the partition of some set U
fof(non_overlapping, axiom, 
(! [X] : (non_overlapping(X) <=> (? [U] : partition(X,U))))
).

%----- Given a partition P, we grow one of its sets B by adding A to B.
fof(insertIntoMember, axiom,
  (! [A, B, P] : insertIntoMember(A,B,P) = 
                 union(union(B,singleton(A)), difference(P,singleton(B)))
  )
).

%----Can also use sum from SET006
fof(d4_tarski,axiom,(
    ! [A,B] :
      ( B = unaryUnion(A)
    <=> ! [C] :
          ( member(C,B)
        <=> ? [D] :
              ( member(C,D)
              & member(D,A) ) ) ) )).

%------------------------------------------------------------------------------

fof(pair, axiom,
	(pair(A,B) = unordered_pair( unordered_pair(A,B), unordered_pair(A,A))) 
).

fof(domain, axiom,
	( ! [X,R] : 
		(member (X, domain(R)) <=> (? [Y] : member(pair(X,Y), R)) )
	)
).

fof(converse, axiom,
	( ! [X,Y,R] : 
		(member(pair(Y,X), converse(R)) <=> member(pair(X,Y), R))
	)
).

fof(cartprod, axiom,
	( ! [A, B, Z] : (member(Z,cartprod(A,B))) <=> ( ? [X,Y] : Z=pair(X,Y)))
).

fof(isrelation, axiom,
	( ! [R] : (isrelation(R) <=> ( ? [X,Y] : (
	subset(R,cartprod(X,Y))
	)))
	)
).

fof(allrelations, axiom,
	(! [A,B] : (allrelations(A,B) = power_set(cartprod(A,B))))
).

fof(range,axiom,
	(! [R] : (range(R) = domain(converse(R)))) 
).

fof(image, axiom,
	(! [Y,R,A] : ( member(Y, image(R,A))) <=> ( ? [X] : ((member(X,A)) & (member (
	pair(X,Y), R
	) )) ))
).

fof(issingleton, axiom, 
	(! [A] : (issingleton(A)) <=> (? [X] : (A=singleton(X))))
).

fof(istrivial, axiom,
	(! [A] : (
		(istrivial(A)) <=> (subset(A, singleton(prod(A))))
	))
).

fof(isruniq, axiom, 
	(! [R] : ( (isruniq(R)) <=> (
		! [X,Y] : (trivial(X) => (trivial(image(R,X)))) 
	)))
).

fof(isfunction, axiom, (! [F]: (isfunction(F) <=> ((isrelation(F)) & (isruniq(F)))))).

fof(outside, axiom, 
	(! [R,A] : (
		outside(R,A) = diff(R, cartprod(A,range(R)))
	))
).

fof(allinjections, axiom,
	(! [A, B, R] : (member (R,allinjections(A,B))) <=>
		( (domain(R) = A) &
		  (subset(range(R),B)) &
		  (isruniq(R)) &
		  (isruniq(converse(R))) &
		  (isrelation(R))
		)
	)
).

%--- N is the set of participants, G the set of goods
fof(allallocations, axiom,
	( ! [N,G,A] :
		(
			(member(A,allallocations(N,G)) <=>
			(
				?[D, E] : (
						(
						subset(D,N) &
						partition(E,G) &
						member(A,allinjections(D,E))
						)
				) 
			)
		)
	)
).

%--- S is the seller
fof(soldallocations, axiom,
	(
	! [S,N,G,A] : ( member(A,soldallocations(S,N,G)) <=> (
		member(outside(A,singleton(S)), allallocations(N,G))
	))
	)
).

fof(isinductive, axiom, ( ![A]: 
	(isinductive(A) <=> (! [X]: ((member(X,A)) => (member(suc(X),A))) ))
)	
).

fof(isnatnumber, axiom, ( ![N]: 
	(isnatnumber(N) <=> (![X]: (isinductive(X) => (member(N,X)))))
)).

%------ END of Axioms

fof(allAllocationsInPowerset, conjecture,
	(
		subset(allallocations(N,G),
			power_set(cartprod(N, diff(power_set(G), singleton(empty_set))))
		)
	)
).

fof(soldAllocationRestriction, conjecture,
	( ! [N,G,A,X] : (
	(member(A, allallocations(N,G))) => (member(outside(A,singleton(X)), 
	soldallocations(diff(N, singleton(X)), G)
	)) 
	))
).

fof(pairDifference, conjecture, ( ! [A, B, C]: (
	diff(singleton( pair(A,B) ) 
	singleton( pair(A,C) )) = 
	cartprod(singleton(A), (diff(singleton(B), singleton(C))))
	))
).

fof(lm142, conjecture,( ! [A]: (
(istrivial(A)) =>
(issingleton(power_set(A))) | (issingleton(sum(power_set(A))))
))).


fof(soldAllocationsFinite, conjecture, (! [S, N, G] : ( 
	((isfinite(N)) & (isfinite(G))) => (isfinite(soldallocations(S,N,G)))	
))).

fof(maxLemma, conjecture, ( ! [A, B, F]: (
	((member(A,B)) & (isfinite(B)) & (isfunction(F))) => (max(image(F,B)) >= apply(F,A))
))).

