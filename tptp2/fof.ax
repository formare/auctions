%------------------------------------------------------------------------------
% File     : <For TPTP use only>
% Domain   : Set Theory
% Axioms   : Additional definitions for partitions 
% Version  : [ATT] axioms
% English  : 

% Refs     : [CKLR:SASI-EC15], Email to G. Sutcliffe
% Source   : [ATT]
% Names    : 

% Status   : Satisfiable
% Syntax   : <Don't worry about this one - we'll do it automatically>
% SPC      : <Don't worry about this one - we'll do it automatically>

% Comments : 
%------------------------------------------------------------------------------

include('Axioms/SET006+0.ax').
include('Axioms/SET006+1.ax').
include('Axioms/SET006+2.ax').

%--- The successor of a set.
fof(suc, axiom, (
	! [A] : (suc(A) = union(A, singleton(A)))
)).

fof(one, axiom, (one = suc(empty_set))).

fof(two, axiom, (two = suc(one))).

%----- A family of sets X is non overlapping if its element are pairwise disjoint
%----- Alternatively, if it is the partition of some set U
fof(non_overlapping, axiom, 
(! [X] : (non_overlapping(X) <=> (? [U] : partition(X,U))))
).

%----- Given a partition P, we grow one of its sets B by adding A to B.
fof(insertIntoMember, axiom,
  (! [A, B, P] : insertIntoMember(A,B,P) = 
                 union(union(B,singleton(A)), difference(P,singleton(B)))
  )
).

%---- Ordered pair (standard Kuratowski definition)
fof(pair, axiom,
	(pair(A,B) = unordered_pair( unordered_pair(A,B), unordered_pair(A,A))) 
).

%---- Given a relation P, returns a function yielding the second component for each pair in P
fof(snd, axiom, (
	! [P,Z] : ((member(Z,snd(P))) <=> (? [X,Y] : (
		(member(pair(X,Y),P)) & (Z=pair(pair(X,Y), Y)) 
	)))
)).

fof(domain, axiom,
	( ! [X,R] : 
		(member (X, domain(R)) <=> (? [Y] : member(pair(X,Y), R)) )
	)
).

fof(converse, axiom,
	( ! [X,Y,R] : 
		(member(pair(Y,X), converse(R)) <=> member(pair(X,Y), R))
	)
).

fof(range,axiom,
	(! [R] : (range(R) = domain(converse(R)))) 
).

fof(cartprod, axiom,
	( ! [A, B, Z] : (member(Z,cartprod(A,B))) <=> ( ? [X,Y] : Z=pair(X,Y)))
).

fof(isrelation, axiom,
	( ! [R] : (isrelation(R) <=> ( ? [X,Y] : (
	subset(R,cartprod(X,Y))
	)))
	)
).

%--- Composition of relations. Note that it reads starting from the left: relcomp (P, Q) first "applies" P, then Q.
%--- Functional composition adopts the opposite convention.
fof(relcomp, axiom, (
	! [P,Q,X] : ((member(X,relcomp(P,Q))) <=> 
		     (? [U,V,W] : (
			(member(pair(U,V),P)) & (member(pair(V,W),Q))				
	)))
)).

fof(allrelations, axiom,
	(! [A,B] : (allrelations(A,B) = power_set(cartprod(A,B))))
).

%--- image(R,A) is the set obtained by applying the relation R to the set A.
fof(image, axiom,
	(! [Y,R,A] : ( member(Y, image(R,A))) <=> ( ? [X] : ((member(X,A)) & (member (
	pair(X,Y), R
	) )) ))
).

%--- Applies a relation to a single argument (typically, a member of its domain; also typically, F will be runiq).
fof(relapply, axiom, (
	! [F, A] : (relapply(F,A) = sum (image(F, singleton(A))))
)).

fof(issingleton, axiom, 
	(! [A] : (issingleton(A)) <=> (? [X] : (A=singleton(X))))
).

%--- A trivial set is either empty or singleton
fof(istrivial, axiom,
	(! [A] : (
		(istrivial(A)) <=> (subset(A, singleton(prod(A))))
	))
).

%--- A relation is right-unique if each member of its domain has only one image (i.e., R is a function)
fof(isruniq, axiom, 
	(! [R] : ( (isruniq(R)) <=> (
		! [X,Y] : (trivial(X) => (trivial(image(R,X)))) 
	)))
).

fof(isfunction, axiom, (! [F]: (isfunction(F) <=> ((isrelation(F)) & (isruniq(F)))))).

fof(outside, axiom, 
	(! [R,A] : (
		outside(R,A) = difference(R, cartprod(A,range(R)))
	))
).

%--- relpaste combines two binary relations P and Q, where pairs from Q
%--- override pairs from P when their first components coincide.
%--- This is particularly useful when P, Q are runiq, and one wants to preserve that property.

fof(relpaste, axiom, (
	! [P,Q] : (relpaste(P,Q) = union(outside(P,domain(Q)),Q))
)).

%--- chi(A,B) is a function yielding 1 on A, and 0 on B\A.
fof(chi, axiom, (
	![A,B] : (chi(A,B) = relpaste(cartprod(B, one),cartprod(A, singleton(one))))
)).

fof(allinjections, axiom,
	(! [A, B, R] : (member (R,allinjections(A,B))) <=>
		( (domain(R) = A) &
		  (subset(range(R),B)) &
		  (isruniq(R)) &
		  (isruniq(converse(R))) &
		  (isrelation(R))
		)
	)
).

fof(allbijections, axiom, (
	(! [A, B, F] : (member(F,allbijections(A,B)) <=> ((member(F,allinjections(A,B)) & (range(F)=B)))))
)).

%--- N is the set of participants, G the set of goods
fof(allallocations, axiom,
	( ! [N,G,A] :
		(
			(member(A,allallocations(N,G))) <=>
			(
				?[D, E] : (
						(
						subset(D,N) &
						partition(E,G) &
						member(A,allinjections(D,E))
						)
				) 
			)
		)
	)
).

%--- S is the seller
fof(soldallocations, axiom,
	(
	! [S,N,G,A] : ( member(A,soldallocations(S,N,G)) <=> (
		member(outside(A,singleton(S)), allallocations(N,G))
	))
	)
).

fof(isinductive, axiom, ( ! [A]: 
	(isinductive(A) <=> (! [X]: ((member(X,A)) => (member(suc(X),A))) ))
)	
).

fof(isnatnumber, axiom, ( ! [N]: 
	(isnatnumber(N) <=> (![X]: (isinductive(X) => (member(N,X)))))
)).

%--- omega is the set of naturals (you need infinity axiom for that; here, we just impose omega exists)
fof(omega, axiom, (
	! [N] : (member(N,omega) <=> isnatnumber(N))
)).

%--- This assumes that the cardinality exists, bypassing ordinal theory
fof(card, axiom, (
	! [F] : ((member(N,omega)) & (? [G] : 
		(member(G,allbijections(F,N))) =>
		((card(F) = N)
	)))
)).

%--- disjointer takes a family of sets and maps each of them to an equinumerous set. The fundamental difference is that the new family has the non-overlapping property.
fof(disjointer, axiom, ( 
	! [A,X] : ((member(X,disjointer(A))) <=> ( ? [B] : ((member(B,A)) & ( X = cartprod(singleton(B),B))))) 
)).

%--- We use disjointer to define the sum of a set of finite sets (e.g., of natural numbers).
%--- Note that "repetitions" are allowed: A can contain distinct equinumerous sets.
fof(setsum, axiom, (
	! [A] : (setsum(A) = card(
			     sum(disjointer(A))
	))
)).

%--- fsetsum(F,A) returns the sum of F over the set A. 
%--- Note that disjointer is used to handle the case of f being non-injective.
fof(fsetsum, axiom, (
	! [F, A] : (fsetsum(F,A) = setsum(disjointer(image(F,A))))
)).

%------ END of Axioms

fof(allAllocationsInPowerset, conjecture,
	(
		subset(allallocations(N,G),
			power_set(cartprod(N, difference(power_set(G), singleton(empty_set))))
		)
	)
).

fof(soldAllocationRestriction, conjecture,
	( ! [N,G,A,X,S] : (
	(member(A, allallocations(N,G))) => (member(outside(A,singleton(X)), 
	soldallocations(S,difference(N, singleton(X)), G)
	)) 
	))
).

fof(pairDifference, conjecture, ( ! [A, B, C]: (
	difference(singleton( pair(A,B) ), singleton( pair(A,C) )) = cartprod(singleton(A), difference(singleton(B), singleton(C)))
	))
).

fof(lm142, conjecture,( ! [A]: (
(istrivial(A)) =>
((issingleton(power_set(A))) | (issingleton(sum(power_set(A)))))
))).

fof(soldAllocationsFinite, conjecture, (! [S, N, G] : ( 
	((isfinite(N)) & (isfinite(G))) => (isfinite(soldallocations(S,N,G)))	
))).

%--- Here, sum means max, and member means <= 
fof(maxLemma, conjecture, ( ! [A, B, F]: (
	((member(A,B)) & (isfinite(B)) & (isfunction(F)) & (subset(range(F),omega)) & (subset(B,domain(F)))) => (member(relapply(F,A),sum(image(F,B))))
))).

fof(setsumPairsInverse, conjecture, (
	! [F, P] : (
	( (isfunction(F)) & (isrelation(P)) & (isruniq(converse(P))) & (isfinite(P)) & (subset(range(F),omega)) & 
	(subset(range(P), domain(F)))) =>
	(fsetsum(relcomp(snd(P), F), P) = fsetsum(F, range(P)))
	)
)).

fof(lm142, conjecture, (
	! [A] : ((trivial(A)) => (member( card(power_set(A)), unordered_pair(one, two) )))
)).

%--- lm112 links the concept of cardinality to the sum over a set: it is somehow a bridge between
%--- set theory and economics (where we use fsetsum to calculate revenues)

fof(lm112, conjecture, (
	! [X,Y,Z] : ( 
  ((subset(Z,union(X,Y))) & (isfinite(Z))) => 
  (fsetsum(chi(X,Y), Z) = card (intersection(Z,X)))
  )
)).

%--- Given an allocation A, all the goods allocated to the participants of a set X are reassigned to a participant I not in X.
%--- We show that the outcome is still an allocation (relative to the original set of participants with X removed).

fof(lm053, conjecture, (
	![A,N,G,I,X] : (
		(
		 (member(A,allallocations(N,G))) & 
		 (member(I, difference(N,X))) &
		 (~(intersection(domain(A), X) = empty_set))
		)
		=> 
		(       
			member(
			union(outside(A ,union(X, singleton(I))), 
			      cartprod(singleton(I), singleton(sum(image(A, union(X,singleton(I))))))), 
			allallocations (difference(N,X), sum(range(A))))
		)
        )
)).

