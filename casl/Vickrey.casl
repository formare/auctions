library Vickrey

%{
It seems that the only alternative to using sorts/types _properly_ (which we are now trying to do) is a full fallback to raw FOL, where the only advantage of CASL over TPTP would be a little syntactic sugar.

CL@TM: How does casl-mode indentation work?
}%

from Basic/SimpleDatatypes get Boolean
from Basic/RelationsAndOrders get TotalOrder

spec Nat =
    sorts
        Nat
    preds
        __>__: Nat * Nat;
        inRange: Nat * Nat; %[ TODO CL: find out whether it's really necessary to _define_ this ]%
    ops
        0: Nat;
end

spec BasicConcepts =
Boolean then 
Nat then
    sorts
        PositiveReal < NonNegativeReal;
    preds
        __>=__: NonNegativeReal * NonNegativeReal;
        __<=__: NonNegativeReal * NonNegativeReal;
        __>__: NonNegativeReal * NonNegativeReal;
    ops
        __-__: NonNegativeReal * NonNegativeReal -> NonNegativeReal;
        0: NonNegativeReal; %[ CL@TM: If we don't want to use actual reals from HasCASL, is this a reasonable way of saying that 0 is a non-negative real number? ]%
end

spec Vectors[sort Elem] given BasicConcepts =
    sorts
    	Vector[Elem];  
    ops
        __[__]: Vector[Elem] * Nat -> Elem;
        %% TM: alternative modelling:     sort NonNegativeReal < Thing; ... ; sort Vector; op component: Vector * Nat -> Thing;
        %[ CL@TM: The following should actually be parameterized by sort; and, can we make length for some SubSort < Vector[...] return Participants < Nat? ]%
        length: Vector[Elem] -> Nat;
        deviationVector: Vector[Elem] * Vector[Elem] * Nat -> Vector[Elem];
end

spec RealVectors =
  BasicConcepts then
  Vectors[sort NonNegativeReal] then
  Vectors[sort PositiveReal] then
  Vectors[sort Boolean] then
  sorts Vector[PositiveReal] < Vector[NonNegativeReal]
end

%% main concepts 
spec SingleGoodAuction = %[ TODO CL: complete from Isabelle ]%
RealVectors then
    sorts
        Participants < Nat; %[ cardinal number of participants (variable usually called n) ]%
        Participant < Nat; %[ ordinal number of one participant ]%
    	Bids < Vector[NonNegativeReal]; 
        Allocation < Vector[Boolean];
        Payments < Vector[NonNegativeReal];
        Valuations < Vector[PositiveReal];
        Valuations < Bids;
    preds
        allocation: Bids * Allocation;
        allocated: Allocation * Bids * Participant;
        payments: Bids * Payments;
    ops
        payment: Payments * Bids * Participant -> NonNegativeReal;
        payoff: NonNegativeReal %[ actually PositiveReal ]% * Boolean * NonNegativeReal -> NonNegativeReal;
        payoff: Valuations * Bids * Allocation * Payments * Participant -> NonNegativeReal;
    forall v:Valuations; b:Bids; x:Allocation; p:Payments; i:Participant
    . allocation(b,x) => length(b) = length(x) %(allocation_length_eq_bids_length)% %[ enforces that the previous two vectors need to have the same length]%
    . allocation(b, x) => (exists n:Participants, k:Participant .
                           n = length(b) /\
                           inRange(n, k) /\
                           allocated(x, b, k) /\
                           (forall j:Participant .
                            inRange(n, j) /\
                            not j = k /\
                            not allocated(x, b, j))) %(allocation_def)%
    . payoff(v, b, x, p, i) = payoff(v[i], True when allocated(x, b, i) else False, payment(p, b, i)) %(payoff_vector_def)%
    forall b:Bids; x:Allocation; n:Participants; winner,other:Participant
    . allocation(b, x) /\
      n = length(b) /\
      inRange(n, winner) /\
      allocated(x, b, winner) /\
      inRange(n, other) /\
      allocated(x, b, other)
      =>
      other = winner %(allocation_unique)% %implied
      %[ proof works with darwin-non-fd ]%
end

spec Maximum[TotalOrder] given BasicConcepts = %[ TODO CL: complete from Isabelle ]%
Vectors[sort Elem] then
    preds
        inArgMaxSet: Vector[Elem] * Nat;
    ops
        maximum: Vector[Elem] -> Elem;
        maximumExcept: Vector[Elem] * Nat -> Elem;
    forall b: Vector[Elem];
           i: Nat
    . inArgMaxSet(b, i) <=> maximum(b) = b[i] %(arg_max_set_def)%
end

spec MaximumNonNegativeReal =
  Maximum[BasicConcepts fit Elem |-> NonNegativeReal]
end

spec SingleGoodAuctionProperties = %[ TODO CL: complete from Isabelle ]%
MaximumNonNegativeReal then
SingleGoodAuction 
then
    preds
        equilibriumWeaklyDominantStrategy: Valuations * Bids * Allocation * Payments;
        efficient:  Valuations * Bids * Allocation;
    forall v: Valuations;
           b: Bids;
           x: Allocation;
           p: Payments
    . efficient(v, b, x) <=> exists n: Participants .
        length(v) = n /\ 
        forall i: Participant . allocated(x, b, i) => inArgMaxSet(v, i) %(efficient_def)%
    . equilibriumWeaklyDominantStrategy(v, b, x, p) <=> exists n: Participants . %[ see above for n ]%
        allocation(b, x) /\
        payments(b, p) /\
        (forall i: Participant . inRange(n, i) =>
          (forall whateverBid: Bids .
            not whateverBid[i] = b[i] 
            =>
            payoff(v, deviationVector(whateverBid, b, i) as Bids, x, p, i) >=
            payoff(v, whateverBid, x, p, i))) %(equilibrium_weakly_dominant_strategy_def)%
end

spec SecondPriceAuction = %[ TODO CL: complete from Isabelle ]%
SingleGoodAuction then
MaximumNonNegativeReal then
    preds
        secondPriceAuction: Allocation * Payments;
        secondPriceAuctionWinner: Participants * Bids * Allocation * Payments * Participant;
        secondPriceAuctionLoser: Participants * Bids * Allocation * Payments * Participant;
    ops
        secondPriceAuctionWinnersPayment:  Bids * Participant -> NonNegativeReal;
    forall n: Participants;
           v: Valuations;
           x: Allocation;
           b: Bids;
           p: Payments;
           winner, loser, i, maxBidder: Participant
    . secondPriceAuctionWinnersPayment(b, winner) = maximumExcept(b, winner) %(second_price_auction_winners_payment_def)%
    . secondPriceAuctionWinner(n, b, x, p, i) <=>
      inRange(n, i) /\
      inArgMaxSet(b, i) /\
      allocated(x, b, i) /\
      payment(p, b, i) = secondPriceAuctionWinnersPayment(b, i) %(second_price_auction_losers_payment_def)%
    . secondPriceAuctionLoser(n, b, x, p, i) <=>
      inRange(n, i) /\
      not allocated(x, b, i) /\
      payment(p, b, i) = 0 %(second_price_auction_loser_def)%
    . secondPriceAuction(x, p) <=>
      (exists n: Participants . length(p) = n /\
        (forall b: Bids . 
          allocation(b, x) /\
          payments(b, p) /\
          (forall i: Participant .
            inRange(n, i) /\
            secondPriceAuctionWinner(n, b, x, p, i) /\
            (forall j: Participant .
              inRange(n, j) /\
              not j = i
              =>
              secondPriceAuctionLoser(n, b, x, p, j))))) %(second_price_auction_def)%
    %[ CL@TM: The following lemmas were needed to enable Isabelle to do the proofs in the Vickrey theory.  If a FOL prover can prove the Vickrey theorems automatically, without further support, what's better:
       * leaving the following lemmas in place and just not proving them with Hets,
       * factoring them out to a separate theory (to make the original theory valid)
       * deleting them? ]%
    %{ not formalising secondPriceAuctionHasOnlyOneWinner for now, as it is not currently needed (see Isabelle) }%
    %[ CL@TM: If, from here on, we "globally" assume "secondPriceAuction(x, p) => ...", can we still name individual axioms in the nested expression?  TM: write a view v : { lhs1 and lhs2-on-the-fly } to { background-theory then rhs-on-the-fly } , where 
      spec lhs1 = sorts ... ops x:...; p:...; n:...; 
                 . secondPriceAuction(x, p) /\
                   n = length(b)
      end ]%
    . secondPriceAuction(x, p) /\
      n = length(b) /\
      %[ TODO CL: Do we need to say that some other lengths should also be n? ]%
      inRange(n, winner) /\
      allocated(x, b, winner)
      =>
      secondPriceAuctionWinner(n, b, x, p, winner) %(allocated_implies_spa_winner)% %implied
    . secondPriceAuction(x, p) /\
      n = length(b) /\
      %[ TODO CL: Do we need to say that some other lengths should also be n? ]%
      inRange(n, loser) /\
      not allocated(x, b, winner)
      =>
      secondPriceAuctionLoser(n, b, x, p, loser) %(not_allocated_implies_spa_loser)% %implied
    . secondPriceAuction(x, p) /\
      n = length(b) /\
      %[ TODO CL: Do we need to say that some other lengths should also be n? ]%
      inRange(n, maxBidder) /\
      b[maxBidder] > maximumExcept(b, maxBidder)
      => secondPriceAuctionWinner(n, b, x, p, maxBidder) %(only_max_bidder_wins)% %implied
    . secondPriceAuction(x, p) /\
      n = length(b) /\
      %[ TODO CL: Do we need to say that some other lengths should also be n? ]%
      inRange(n, winner) /\
      allocated(x, b, winner)
      =>
      payoff(v, b, x, p, i) =
      v[winner] - maximumExcept(b, winner) %(second_price_auction_winner_payoff)% %implied
    . secondPriceAuction(x, p) /\
      n = length(b) /\
      %[ TODO CL: Do we need to say that some other lengths should also be n? ]%
      inRange(n, loser) /\
      not(allocated(x, b, loser))
      =>
      payoff(v, b, x, p, loser) =
      0 %(second_price_auction_loser_payoff)% %implied
    . secondPriceAuction(x, p) /\
      n = length(b) /\
      %[ TODO CL: Do we need to say that some other lengths should also be n? ]%
      n > 0 /\
      inRange(n, winner) /\
      allocated(x, b, winner)
      =>
      payoff(v, b, x, p, winner)
      = maximumExcept(deviationVector(b, v, winner), winner) %(winners_payoff_on_deviation_from_valuation)% %implied
end

spec Vickrey =
SecondPriceAuction then
SingleGoodAuctionProperties then
    forall v: Valuations; 
           x: Allocation;
           p: Payments
    . secondPriceAuction(x, p) => equilibriumWeaklyDominantStrategy(v, v %[ i.e. b ]%, x, p) %(vickreyA)% %implied
    . secondPriceAuction(x, p) => efficient(v, v %[ i.e. b ]%, x) %(vickreyB)% %implied
end
